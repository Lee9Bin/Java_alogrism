*객체
정의: 의사나 행위가 미치는 대상(사전적 의미)
     구체적, 추상적 데이터의 단위(학생, 회원, 생산, 주문)

-객체 지향 프로그램 구현
1. 객체를 정의
2. 제공하는 기능들을 구현
3. 객체들의 기능들 간의 소통을 통하여 객체간 협력 구현

ex) class 학생{
    속성이 멤버변수로 선언된다.
    int studentId;
    String studentName;

    기능은 함수로 구현
    접근제어자 반환타입 함수이름(매개변수){
    지역변수(함수내에서만 사용하는 변수, 함수가 종료되면 자동으로 반환되는 변수)
    }
}


*생성자
-일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new와 함께 호출
 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출
    클래스 참조변수 = new 클래스
new키워드에 의해 객체(클래스 인스턴스가 힙메모리에 생성이 되고)가 생성 참조변수에는 인스턴스 값을 가르키는 메모리 주소값이 담김
즉 참조변수는 인스턴스를 가르키는 리모컨이고 인스턴스는 실제 값이라 생각해보자

-기본생성자
클래스 내부에 생성자가 하나도!!! 없다면 컴파일러가 생성자 코드를 넣어줌
그래서 이때는 구현하지 않아도 생성자 호출 가능

-생성자 오버로딩
생성자를 두개 이상 구현하는 경우
따라서
클래스(매개변수){
} ---->구현을 하면 컴파일러는 기본 생성자를 넣어주지 않기 때문에
클래스(){} 기본생성자를 사용할거면 선언해야해


*접근제어자
클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드

-private : 같은 클래스 내부에서만 접근 가능 ( 외부 클래스, 상속 관계의 클래스에서도 접근 불가)
           멤버 변수에 대해 접근 수정할 수 있게 get(), set()메서드를 사용
           그렇다면 get()만 쓰면 읽기만 가능하게 하지
           이를통해 정보 은닉을 하고 최소한의 정보를 오픈함으로써 객체의 오류를 방지
-아무것도 없음 (default) : 같은 패키지 내부에서만 접근 가능 ( 상속 관계라도 패키지가 다르면 접근 불가)
-protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
-public : 클래스의 외부 어디서나 접근 할 수 있음


*this
-인스턴스 자신의 메모리를 가르킨다.
-생성자에서 또 다른 생성자를 호출 할때 사용
ex)public Person() {
   		this("이름없음", 1);
   	}

   	public Person(String name, int age) {
   		this.name = name;
   		this.age = age;
   	}
-자신의 주소값을 반환


*static 변수
데이터 영역 메모리
인스턴스가 생성될 때 만들어지는 변수가 아닌, 처음 프로그램이 메모리에 로딩될 때 메모리를 할당
(따라서 클래스 이름으로 호출 가능)
여러 인스턴스가 공유하는 기준 값이 필요한 경우
ex)학생마다 새로운 학번을 만들어야 하는 경우


*클래스 상속
새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능을 확장해서 구현
이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 상속

-상속의 문법
    하위        상위
class B extends A{
}

-하위 클래스가 생성 되는 과정
하위 클래스를 생성하면 상위 클래스가 먼저 생성 됨
클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출 한다.
어떻게?? super 키워드를 통해

-super
하위 클래스에서 가지는 상위 클래스에 대한 참조 값
super()는 상위 클래스의 기본 생성자를 호출 함
하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출 된다. ( 이때 반드시 상위 클래스의 기본 생성자가 존재 해야 함)
상위 클래스의 기본 생성자가 없는 경우 ( 다른 생성자가 있는 경우 ) 하위 클래스에서는 생성자에서는 super를 이용하여 명시적으로 상위 클래스의 생성자를 호출 함
super는 생성된 상위 클래스 인스턴스의 참조 값을 가지므로 super를 이용하여 상위 클래스의 메서드나 멤버 변수에 접근할 수 있음

-상속에서 인스턴스 메모리의 상태
항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.

-형변환(업캐스팅)
상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성 가능
Customer customerLee = new VIPCustomer();
상위 클래스 타입의 변수에 하위 클래스 변수가 대입 가능
VIPCustomer vCustomer = new VIPCustomer();
addCustomer(vCustomer);
int addCustomer(Customer customer){
}
why? 항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.
하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환이 가능하다.
상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅)이 된다.
(그 역은 성립하지 않음)

주의!!
VIPCustomer() 생성자에 의해 VIPCustomer 클래스의 모든 멤버 변수에 대한 메모리는 생성되었지만,
변수의 타입이 Customer 이므로 실제 접근 가능한 변수나 메서드는 Customer의 변수와 메서드임

-하위 클래스에서 메서드 재정의하기(오버라이딩)
상위클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우
하위 클래스에서 동일한 이름!!!의 메서드를 재정의 할 수 있다.


* @overriding 애노테이션
애노테이션은 원래 주석이라는 의미
컴파일러에게 특별한 정보를 제공해주는 역할
@Overrid : 재정의된 메서드라는 정보 제공
@FunctionalInterface: 함수형 인터페이스라는 정보 제공
@Deprecated: 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용된다.
@SupperssWarnings: 특정 경고가 나타나지 않도록한다.

*메서드의 호출과 실행
자바는 모든 메서드가 가상 메서드.
메서드(함수)의 이름은 주소값을 나타낸다.
메서드는 명령어의 set이고(Instruction Set), 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치함
해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행된다.
이때 메서드에서 사용하는 변수들은 스택 메모리에 위치하게 된다.
따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
인스턴스가 생성되면 변수는 힙 메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드된다.

*가상 메서드
메서드가 호출되면 메서드 이름으로 바로 호출되는게 아니라 메소드 이름이 가리키는 가상 테이블을 보고
각 클래스가 가지고 있는 메서드 주소를 참조해서 호출한다.
가상 메서드 테이블에서 해당 메서드에 대한 주소를 가지고 있다.
재정의 된 경우에는 재정의된 메서드의 주소를 가르킨다.
ex)                          메서드      주소               영역
-포유류클래스 가상 메서드 테이블   a(재정의됨)   0xfwefw --->  [포유류클래스 a()]
                      b(재정의 되지 않음) 0xf1234 --->  [포유류클래스 b()]<-
-사람클래스 가상메서드 테이블     a(재정의됨)   0xfwefw --->  [사람클래스 a()]   |
                      b(재정의 되지 않음) 0xf1234 ----------------------|

*다형성
하나의 코드가 여러 자료형으로 구현되어 실행된다.
같은 코드에서 여러 다른 실행 결과가 나온다.
정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
잘 활용하면 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있다.
상속과 오버라이딩을 통해 구현한다.

*다운캐스팅
업캐스팅된 클래스를 다시 원래의 타입으로 형변환 하는거
instanceof로 원래 누구의 인스턴스인지 체크 가능 이를 활용하여 조건절에 맞으면 다운캐스팅을 실행
하위클래스 변수 = (하위클래스) 변수

*추상 클래스
구현 코드 없이 메서드의 선언만 있는 추상 메서드(abstract method)를 포함한 클래스
메서드 선언(declaration) : 반환타입, 메서드 이름, 매개변수로 구성
메서드 정의(definition) : 메서드 구현(implementation)과 동일한 의미 구현부(body) 를 가짐 ({ })
예) int add(int x, int y); // 선언
int add(int x, int y){ } // 구현부가 있음, 추상 메서드 아님
abstract 예약어를 사용
추상 클래스는 new 할 수 없음 ( 인스턴스화 할 수 없음 )

*템플릿 메서드
추상 메서드나 구현 된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
final로 선언하여 하위 클래스에서 재정의 할 수 없게 한다.
프레임워크에서 많이 사용되는 설계 패턴
추상 클래스로 선언된 상위 클래스에서 템플릿 메서드를 활용하여 전체적인 흐름을 정의 하고 하위 클래스에서
다르게 구현되어야 하는 부분은 추상 메서드로 선언하여 하위 클래스에서 구현 하도록 한다.

-final
final 변수 : 값이 변경될 수 없는 상수
public static final double PI = 3.14;

final 메서드 : 하위 클래스에서 재정의 할 수 없는 메서드
final 클래스 : 상속할 수 없는 클래스
