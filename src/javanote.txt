*객체
정의: 의사나 행위가 미치는 대상(사전적 의미)
     구체적, 추상적 데이터의 단위(학생, 회원, 생산, 주문)

-객체 지향 프로그램 구현
1. 객체를 정의
2. 제공하는 기능들을 구현
3. 객체들의 기능들 간의 소통을 통하여 객체간 협력 구현

ex) class 학생{
    속성이 멤버변수로 선언된다.
    int studentId;
    String studentName;

    기능은 함수로 구현
    접근제어자 반환타입 함수이름(매개변수){
    지역변수(함수내에서만 사용하는 변수, 함수가 종료되면 자동으로 반환되는 변수)
    }
}


*생성자
-일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new와 함께 호출
 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출
    클래스 참조변수 = new 클래스
new키워드에 의해 객체(클래스 인스턴스가 힙메모리에 생성이 되고)가 생성 참조변수에는 인스턴스 값을 가르키는 메모리 주소값이 담김
즉 참조변수는 인스턴스를 가르키는 리모컨이고 인스턴스는 실제 값이라 생각해보자

-기본생성자
클래스 내부에 생성자가 하나도!!! 없다면 컴파일러가 생성자 코드를 넣어줌
그래서 이때는 구현하지 않아도 생성자 호출 가능

-생성자 오버로딩
생성자를 두개 이상 구현하는 경우
따라서
클래스(매개변수){
} ---->구현을 하면 컴파일러는 기본 생성자를 넣어주지 않기 때문에
클래스(){} 기본생성자를 사용할거면 선언해야해


*접근제어자
클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드

-private : 같은 클래스 내부에서만 접근 가능 ( 외부 클래스, 상속 관계의 클래스에서도 접근 불가)
           멤버 변수에 대해 접근 수정할 수 있게 get(), set()메서드를 사용
           그렇다면 get()만 쓰면 읽기만 가능하게 하지
           이를통해 정보 은닉을 하고 최소한의 정보를 오픈함으로써 객체의 오류를 방지
-아무것도 없음 (default) : 같은 패키지 내부에서만 접근 가능 ( 상속 관계라도 패키지가 다르면 접근 불가)
-protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
-public : 클래스의 외부 어디서나 접근 할 수 있음


*this
-인스턴스 자신의 메모리를 가르킨다.
-생성자에서 또 다른 생성자를 호출 할때 사용
ex)public Person() {
   		this("이름없음", 1);
   	}

   	public Person(String name, int age) {
   		this.name = name;
   		this.age = age;
   	}
-자신의 주소값을 반환


*static 변수
데이터 영역 메모리
인스턴스가 생성될 때 만들어지는 변수가 아닌, 처음 프로그램이 메모리에 로딩될 때 메모리를 할당
(따라서 클래스 이름으로 호출 가능)
여러 인스턴스가 공유하는 기준 값이 필요한 경우
ex)학생마다 새로운 학번을 만들어야 하는 경우


*클래스 상속
새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능을 확장해서 구현
이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 상속

-상속의 문법
    하위        상위
class B extends A{
}

-하위 클래스가 생성 되는 과정
하위 클래스를 생성하면 상위 클래스가 먼저 생성 됨
클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출 한다.
어떻게?? super 키워드를 통해

-super
하위 클래스에서 가지는 상위 클래스에 대한 참조 값
super()는 상위 클래스의 기본 생성자를 호출 함
하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출 된다. ( 이때 반드시 상위 클래스의 기본 생성자가 존재 해야 함)
상위 클래스의 기본 생성자가 없는 경우 ( 다른 생성자가 있는 경우 ) 하위 클래스에서는 생성자에서는 super를 이용하여 명시적으로 상위 클래스의 생성자를 호출 함
super는 생성된 상위 클래스 인스턴스의 참조 값을 가지므로 super를 이용하여 상위 클래스의 메서드나 멤버 변수에 접근할 수 있음

-상속에서 인스턴스 메모리의 상태
항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.

-형변환(업캐스팅)
상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성 가능
Customer customerLee = new VIPCustomer();
상위 클래스 타입의 변수에 하위 클래스 변수가 대입 가능
VIPCustomer vCustomer = new VIPCustomer();
addCustomer(vCustomer);
int addCustomer(Customer customer){
}
why? 항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.
하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환이 가능하다.
상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅)이 된다.
(그 역은 성립하지 않음)

주의!!
VIPCustomer() 생성자에 의해 VIPCustomer 클래스의 모든 멤버 변수에 대한 메모리는 생성되었지만,
변수의 타입이 Customer 이므로 실제 접근 가능한 변수나 메서드는 Customer의 변수와 메서드임

-하위 클래스에서 메서드 재정의하기(오버라이딩)
상위클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우
하위 클래스에서 동일한 이름!!!의 메서드를 재정의 할 수 있다.


* @overriding 애노테이션
애노테이션은 원래 주석이라는 의미
컴파일러에게 특별한 정보를 제공해주는 역할
@Overrid : 재정의된 메서드라는 정보 제공
@FunctionalInterface: 함수형 인터페이스라는 정보 제공
@Deprecated: 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용된다.
@SupperssWarnings: 특정 경고가 나타나지 않도록한다.

*메서드의 호출과 실행
자바는 모든 메서드가 가상 메서드.
메서드(함수)의 이름은 주소값을 나타낸다.
메서드는 명령어의 set이고(Instruction Set), 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치함
해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행된다.
이때 메서드에서 사용하는 변수들은 스택 메모리에 위치하게 된다.
따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
인스턴스가 생성되면 변수는 힙 메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드된다.

*가상 메서드
메서드가 호출되면 메서드 이름으로 바로 호출되는게 아니라 메소드 이름이 가리키는 가상 테이블을 보고
각 클래스가 가지고 있는 메서드 주소를 참조해서 호출한다.
가상 메서드 테이블에서 해당 메서드에 대한 주소를 가지고 있다.
재정의 된 경우에는 재정의된 메서드의 주소를 가르킨다.
ex)                          메서드      주소               영역
-포유류클래스 가상 메서드 테이블   a(재정의됨)   0xfwefw --->  [포유류클래스 a()]
                      b(재정의 되지 않음) 0xf1234 --->  [포유류클래스 b()]<-
-사람클래스 가상메서드 테이블     a(재정의됨)   0xfwefw --->  [사람클래스 a()]   |
                      b(재정의 되지 않음) 0xf1234 ----------------------|

*다형성
하나의 코드가 여러 자료형으로 구현되어 실행된다.
같은 코드에서 여러 다른 실행 결과가 나온다.
정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
잘 활용하면 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있다.
상속과 오버라이딩을 통해 구현한다.

*다운캐스팅
업캐스팅된 클래스를 다시 원래의 타입으로 형변환 하는거
instanceof로 원래 누구의 인스턴스인지 체크 가능 이를 활용하여 조건절에 맞으면 다운캐스팅을 실행
하위클래스 변수 = (하위클래스) 변수

*추상 클래스
구현 코드 없이 메서드의 선언만 있는 추상 메서드(abstract method)를 포함한 클래스
메서드 선언(declaration) : 반환타입, 메서드 이름, 매개변수로 구성
메서드 정의(definition) : 메서드 구현(implementation)과 동일한 의미 구현부(body) 를 가짐 ({ })
예) int add(int x, int y); // 선언
int add(int x, int y){ } // 구현부가 있음, 추상 메서드 아님
abstract 예약어를 사용
추상 클래스는 new 할 수 없음 ( 인스턴스화 할 수 없음 )

*템플릿 메서드
추상 메서드나 구현 된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
final로 선언하여 하위 클래스에서 재정의 할 수 없게 한다.
프레임워크에서 많이 사용되는 설계 패턴
추상 클래스로 선언된 상위 클래스에서 템플릿 메서드를 활용하여 전체적인 흐름을 정의 하고 하위 클래스에서
다르게 구현되어야 하는 부분은 추상 메서드로 선언하여 하위 클래스에서 구현 하도록 한다.

-final
final 변수 : 값이 변경될 수 없는 상수
public static final double PI = 3.14;

final 메서드 : 하위 클래스에서 재정의 할 수 없는 메서드
final 클래스 : 상속할 수 없는 클래스

*인터페이스
모든 메서드가 추상 메서드로 선언이 된다.(자바 8 부터 디폴트 메서드(default method)와 정적 메서드(static method) 기능의 제공으로 일부 구현 코드가 있다.)
모든 변수는 상수로 선언이 된다(public static final).
클래스에서 특정한 기능을 구현하도록 강제하는 역할을 한다.
따라서 추상클래스에서 상속을 통해 구현하는 느낌과 비슷하다고 생각이된다.

인터페이스 사이에서도 상속이 가능

*Object 클래스
모든클래스의 최상위 클래스
모든 클래스는 Object에서 상속받고, Object 클래스의 메서드 중 일부는 재정의해서 사용할 수 있음
컴파일러가 extends Object를 추가함 ex) class Student => class Student extends Object

-equals(), hashCode()메서드
equals메서드는 두 인스턴스의 주소값을 비교하여 같으면 true 다르면 false를 반환한다.
따라서 인스턴스가 다르더라도 논리적으로 동일하면 true를 반환하도록 재정의 가능하다
hashCode메서드는 (힙메모리에 인스턴스가 저장되는 방식이 hash방식)인스턴스의 주소를 반환한다.
----> 인스턴스가 같다: 두 인스턴스에 대한 equals()의 반환 값이 true 동일한 hashCode() 값을 반환 해야한다.
논리적으로 동일함을 위해 equals() 메서드를 재정의 하였다면 hashCode()메서드도 재정의 하여 동일한 hashCode 값이 반환되도록 한다.

*자료구조
프로그램에서 사용할 많은 데이터를 메모리 상에서 관리하는 여러 구현방법들
효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다.
자료의 효율적인 관리는 프로그램의 수행속도와 밀접한 관련이 있다.
따라서, 여러 자료 구조 중에서 구현하려는 프로그램에 맞는 최적의 자료 구조를 활용해야 하므로 자료구조에 대한 이해를 해야한다.

--선형자료구조 = 한줄로 자료를 관리한다. 앞뒤 요소가 1대1 관계
-배열(Array): 선형으로 자료를 관리하고 정해진 크기의 메모리를 먼저 할당받아 사용하고, 자료의 물리적 위치와 논리적위치가 같다(어느 위치에 있는 요소를 꺼내오는 연산이 빨라,추가 삭제가 연산이 느려).

-연결리스트(LinkedList) = 선형으로 자료를 관리하고 자료가 추가될 때마다 메모리를 할당받고, 자료는 링크로 연결된다. 따라서 자료의 물리적 위치와 논리적 위치가 다를 수 있다.(삽입 삭제의 연산이 빨라, 위치를 찾는 연산이 느려)

-스택(Stack) = 가장 나중에 입력된 데이터가 가장 먼저 출려되는 구조(프링글스과자 생각)

-큐(Queue) = 가장 먼저 입력된 자료가 가장 먼저 출력 되는 구조(줄서기 생각)

--비선형자료구조
트리(Tree) = 부모 노드와 자식 노드간의 연결로 이루어진 자료구조
-이진 트리(binary tree): 부모노드에 자식 노드가 두개 이하인 트리
 대표적으로 힙(heap)과 이진 검색 트리(binary search tree)를 주로 사용
 힙 = 우선순위 큐를 구현할 때 사용된다.
     Max heap구조 - 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우
     Min heap구조 - 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는 경우

 이진 검색 트리 = 검색을 위한 자료구조 자료(key)의 중복을 허용하지 않는다.
              왼쪽 자식 노드는 부모보다 작은 값, 오른쪽 자식은 큰 값을 가진다.
              검색에 걸리는 시간이 부모를 기준으로 반반씩 쪼개 지기 때문에 log(n)의 시간복잡도를 가진다.

그래프 = 정점과 간선들의 유한 집합
-인접행렬과 인접 리스트로 구현 할 수 있다. 이때 그래프를 탐색하는 대표적인 방법 DFS, BFS
1: 1, 2, 3     0 1 0 1
2: 1, 4        1 0 1 0
3: 1           0 1 0 0
4: 2           1 0 0 0

해싱 = 자료 검색을 하기 위한 자료구조
      키에 대한 자료를 검색하기 위한 사전 개념의 자료구조 --- 파이썬의 딕셔너리와 같은..
      23: 23,123,224 24: 24,124,224 ...


*재너릭 자료형
클래스에서 사용하는 변수의 자료형이 여려개 일 수 있는데, 그 기능은 동일한 경우 클래스의 자료형을 특정하지 않고 추후 해당 클래스를 사용할 때 지정할 수 있도록 선언
실제 사용되는 자료형의 변환은 컴파일러에 의해 검증되므로 안정적이다.
컬렉션 프레임워크에서 많이 사용되고 있다.

-자료형 매개변수라는 의미의 T: 이 클래스를 사용하는 시점에 실제 사용한 자료형을 지정, static 변수는 사용할 수 없다.
(E: element, K: key 등 여러 알파벳을 의미에 따라 사용가능)

-<> 다이아몬드 연산자
<>를 다이아몬드 연산자라 한다.
ArrayList list = new ArrayList<>();  //다이아몬든 연산자 내부에서 자료형은 생략가능 함

-<T extends 클래스>
T라는 위치에 어떤 자료형이 들어갈 수 있게돼 근데 만약 예제에서 프린터에 물이 들어간다? 그럼 안되잖아.
그래서 상속을 사용해 T자료형의 범위를 제한 할 수 있다.

-제너릭 메서드
자료형 매개변수를 메서드의 매개변수나 반환 값으로 가지는 메서드는 자료형 매개 변수가 하나 이상인 경우도 있다.
제네릭 클래스가 아니어도 내부에 제네릭 메서드는 구혀현하요 사용할 수 있다.
ex) public <자료형 매개변수 > 반환형 메서드 이름(자료형 매개변수..){}

*컬렉션 프레임워크
프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK라이브러리, 개발에 소요되는 시간을 절약하면서 최적화 된 알고리즘을 사용할 수 있다.
여러 구현 클래스와 인터페이스의 활용에 대한 이해가 필요하다.
java.util 패키지에 구현되어 있다.
자료구조에 따라 우리가 만든 클래스에 대해서는 equals,hashcode   comparable,Comparator을 재정의 해야해 !!!!

*Iterator
컬렉션 프레임워크에 저장된 요소들을 하나씩 차례로 참조한다.
순서가 있는 List인터페이스의 경우는 사용하지 않고 get메서드를 활용 할 수 있지만
set 인터페이스의 경우 get메서드가 제공되지 않으므로 iterator을 활용하여 객체를 순회한다.
hasNext(): 이후에 요소가 더 있는지 체크하는 메서드, 요소가 있다면 true를 반환
next(): 다음에 있는 요소를 반환

*인스턴스 내부클래스
내부적으로 사용할 클래스를 선언 (private으로 선언하는 것을 권장한다 why? private이 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있기 때문이다.)
외부 클래스가 생성된 후 생성된다. ( 정적 내부 클래스와 다르다. why? static이니까~)

*정적 내부클래스
외부 클래스 생성과 무관하게 사용할 수 있다.
정적 변수, 정적 메서드 사용한다
                 변수 유형         사용가능 여부
일반메서드: 외부클래스의 인스턴스 변수         x
         외부클래스의 정적 변수            o
         정적 내부 클래스의 인스턴스 변수    o
         정적 내부 클래스의 정적 변수       o
정적메서드: 외부클래스의 인스턴스 변수         x
         외부클래스의 정적 변수            o
         정적 내부 클래스의 인스턴스 변수    x
         정적 내부 클래스의 정적 변수       o

*지역 내부클래스
지역 변수와 같이 메서드 내부에서 정의하여 사용하는 클래스
메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라진다.
메서드 호출 이후에도 사용해야 하는 경우가 있을 수 있으므로 지역 내부 클래스에서 사용하는 메서드의 지역 변수나 매개 변수는 final로 선언된다.

*익명 내부클래스
이름이 없는 클래스 (지역 내부 클래스의 이름은 실제로 호출되는 경우가 없다.)
클래스의 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환
인터페이스나 추상 클래스 자료형의 변수에 직접 대입하여 클래스를 생성하거나 지역 내부 클래스의 메서드 내부에서 생성하여 반환 할 수 있다.

*람다식
자바는 객체 지향 프로그래밍 : 기능을 수행하긴 위해서는 객체를 만들고 그 객체 내부에 멤버 변수를 선언하고 기능을 수행하는 메서드를 구현한다.
자바 8부터 함수형 프로그래밍 방식을 지원하고 이를 람다식이라 한다.
함수의 구현과 호출만으로 프로그래밍이 수행되는 방식 (함수형 프로그래밍(Functional Programming: FP))
함수형 프로그래밍은 순수함수(pure function)를 구현하고 호출함으로써 외부 자료에 부수적인 영향(side effect)를 주지 않도록 구현하는 방식입니다.
순수 함수란 매개변수만을 사용하여 만드는 함수 입니다. 즉, 함수 내부에서 함수 외부에 있는 변수를 사용하지 않아 함수가 수행되더라도 외부에는 영향을 주지 않습니다.
함수를 기반으로 하는 프로그래밍이고 입력받는 자료 이외에 외부 자료를 사용하지 않아 여려 자료가 동시에 수행되는 병렬처리가 가능합니다.
함수형 프로그래밍은 함수의 기능이 자료에 독립적임을 보장합니다.->이는 동일한 자료에 대해 동일한 결과를 보장하고, 다양한 자료에 대해 같은 기능을 수행할 수 있습니다.

-문법
익명 함수 만들기
매개 변수와 매개변수를 이용한 실행문 (매개변수) -> {실행문;}
ex) int add(int x, int y){

        return x+y;          --->    (int x, int y){return x+y;}
    }
    매개 변수가 하나인 경우 자료형과 괄호 생략가능    str->{System.out.println(str);}
    매개변수가 두 개이상인 경우 괄호를 생략할 수 없음   x, y -> {System.out.println(x+y);}  //오류
    실행문이 한 문장인 경우 중괄호 생략 가능        str-> System.out.println(str);
    실행문이 한 문장이라도 return문(반환문)은 중괄호를 생략할 수 없음   str-> return str.length();  //오류
    실행문이 한 문장의 반환문인 경우엔 return과 중괄호를 모두 생략   (x, y) -> x+y;
                                                      str -> str.length;

*스트림
.자료의 대상과 관계없이 동일한 연산을 수행한다. (배열, 컬렉션을 대상으로 연산을 수행한다.)
일관성 있는 연산으로 자료의 처리르 쉽고 간단하게 해준다.
.한번 생성하고 사용한 스트림은 재사용 할 수 없다. -> 연산을 수행하면 스트림은 소모되므로 다른 연산을 수행하기 위해 다시 생성해야한다.
.스트림 연산은 중간연산과 최종 연산으로 구분된다. -> 중간 연산은 여러개의 연산이 적용될 수 있지만 최종 연산은 마지막에 한번만 적용된다.
                                        (최종 연산이 호출돼야 중간 연산에 대한 연산이 이루어진다.->따라서 중간 연산에 대한 결과를 중간에 알수없다.)
 ex) 중간연산: filter(), map(), sorted()
     최종연산: forEach(), count(), sum()

-reduce()
정의된 연산이 아닌 프로그래머가 직접 구현한 연산을 적용할 수 있다. -> T reduce(T identify, BinaryOperator<T> accumulator)
최종 연산으로 스트림의 요소를 소모하며 연산을 수행한다.
배열의 모든 요소의 합을 구하는 reduce() 연산
구현 ex) Arrays.stream(arr).reduce(0, (a,b)->a+b));
reduce() 메서드의 두 번째 요소로 전달되는 람다식에 따라 다양한 기능을 수행 할 수 있다.
람다식을 직접 구현하거나 람다식이 긴 경우 BinaryOperator를 구현한 클래스를 사용 한다.

*예외처리
-프로그램에서의 오류
컴파일오류: 프로그램 코드 작성 중 발생하는 문법적 오류
실행오류: 실행 중인 프로그램이 의도하지 않은 동작(버그)을 하거나 프로그램이 중지 되는 오류
       실행오류는 비정상 종료가 되는 경우 시스템의 심각한 장애를 발생 할 수 있다.

-예의처리의 중요성
프로그램의 비정상 종료를 피하고 시스템이 원활히 실행되도록 한다.
실행 오류가 발생한 경우 오류의 과정을 재현 하는 것은 현실적으로 힘들다. -> 그래서 오류가 발생한 경우 log를 남겨 추후 log분석을 통해 원인을 파악하여 버그를 수정하는 것이 중요하다.
(log를 어떻게 남길지가 관건)

-try catch
try 블록에는 예외가 발생할 가능성이 있는 코드를 작성하고 try 블록 안에서 예외가 발생하는 경우 catch 블록이 수행된다.
ex) trt{
        예외가 발생할 수 있는 코드부분
   }catch(처리할 예외 타입e){
       try블록에서 예외가 발생할 경우 처리하는 부분(로그를 남기는등)
   }

-try catch finally
finally 블럭에서 파일를 닫거나 네트워크를 닫는 등의 리소스 해제 구현한다.
try{} 블럭이 수행되는 경우, finally{} 블럭은 항상 수행 된다.
여러 개의 예외 블럭이 있는 경우 각각에서 리소스를 해제하지 않고 finally 블록에서 해제하도록 구현한다.
close()를 명시적을 호출해줘야 하는 상황이 생긴다. 그래서 나온게 try-with-resources

-try with resources
리소스를 사용하는 경우 close() 하지 않아도 자동으로 해제 해준다.(자바 7부터 제공)
리소스를 try() 내부에서 선언해야만 한다.
close()를 명시적으로 호출하지 않아도 try{}블록에서 열린 리소스는 정상적인 경우나 예외가 발생한 경우 모두 자동으로 해제된다.
해당 리소스 클래스가 AutoCloseable 인터페이스를 구현 해야 한다.(FileInputStream의 경우에는 AutoCloseable을 구현하고 있다.)
자바 9 부터 리소스는 try() 외부에서 선언하고 변수만을 try(obj) 와 같이 사용할 수 있다.

-예외처리 미루기
예외 처리는 예외가 발생하는 문장에서 try-catch 블록으로 처리하는 방법과 이를 사용하는 부분에서 처리하는 방법 두 가지가 있다.
throws를 이용하면 예외가 발생할 수 있는 부분을 사용하는 문장에서 예외를 처리할 수 있다.

-사용자 정의 예외 클래스
자바에서 제공되는 예외 클래스외에 프로그래머가 직접 만들어야 하는 예외가 있을 수 있다. ex) 비밀번호 등
기존 예외 클래스중 가장 유사한 예외 클래스에서 상속 받아 사용자 정의 예외 클래스를 만든다.(기본적으로 Exception 클래스를 상속해서 만들 수 있다.)

-logging
시스템 운영에 대한 기록
오류가 발생 했을 때 그 오류에 대한 기록을 남겨 디버깅을 용이하게 한다.
로그 파일에 기록하는 코드를 추가하여 필요한 정보가 로그로 남을 수 있도록 한다.
디버깅, 시스템 에러 추적, 성능, 문제점 향상들을 위해 사용
어느정도까지 로그를 남길 것인가?
너무 적은 로그 : 정확한 시스템의 상황을 파악하기 어렵다.
너무 많은 로그 : 빈번한 file I/O의 오버헤드와 로그 파일의 백업 문제등이 생긴다.

-java.util.logging
자바에서 기본적으로 제공되는 log package
파일이나 콘솔에 로그 내용을 출력할 수 있다.
jre/lib/logging.properties 파일을 편집하여 로그의 출력방식 로그 레벨을 변경 할 수 있다.
logging 패키지에서 제공하는 로그 레벨은 severe, warning, info, config, fine, finer, finest
오픈소스로는 log4j를 많이 사용하고 있다.

*자바의 입출력을 위한 I/O 스트림
네트워크에서 자료의 흐름이 물의 흐름과 같다는 비유에서 유래됐다.
자바는 다양한 입출력 장치에 독립적으로 일관성 있는 입출력을 입출력 스트림을 통해 제공한다.
입출력 구현되는 예시: 파일 디스크, 키보드, 마우스 등 모든 자료가 입력되 고 출력되는 곳

-구분
대상 기준 : 입력 스트림/ 출력 스트림
입력 스트림: 대상으로부터 자료를 읽어 들이는 역할(예시: FileInputStream, FileReader, BufferedInputStream, BufferedReader 등)
출력 스트림: 대상으로 자료를 출력하는 스트림(예시: FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등)

자료의 종류: 바이트 스트림/ 문자 스트림
바이트 스트림: 동영상, 음악 파일, 실행 파일등의 자료를 읽고 쓸 때(FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream 등)
문자 스트림: 바이트 단위로 자료를 처리하면 문자는 꺠진다. 인코딩에 맞게 2바이트 이상으로 처리하도록 구현된 스트림(FileReader, FileWriter, BufferedReader, BufferedWriter 등)

기능: 기반 스트림/ 보조 스트림
기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림(FileInputStream, FileOutputStream, FileReader, FileWriter 등)
보조 스트림 : 직접 읽고 쓰는 기능은 없이 추가적인 기능을 더해주는 스트림(InputStreamReader, OutputStreamWriter, BufferedInputStream, BufferedOutputStream 등)
           보조 스트림은 직접 읽고 쓰는 기능은 없으므로 항상 기반 스트림이나 또 다른 보조 스트림을 생성자의 매개 변수로 포함한다.


-Decorator Pattern
자바의 입출력 스트림은 decorator pattern 이다. 여러 decorator들을 활용하여 다양한 기능을 제공할 수 있다.
상속 보다 유연한 구현 방식이다.
데코레이터는 다른 데코레이터나 또는 컴포넌트를 포함해야 한다.
지속적인 기능의 추가와 제거가 용이하다.
decorator와 component는 동일한 것이 아님 ( 기반 스트림 클래스가 직접 읽고 쓸수 있음, 보조 스트림은 추가적인 기능 제공)

*Thread
process: 프로그램이 실행되면 메모리에 올라가고 이상태를 프로세스라 한다.
thread: 하나의 프로세스는 하나 이상의 thread를 가지게 되고, 실제 작업을 수행하는 단위이다.

-multi-threading
여러 thread가 동시에 수행되는 프로그래밍, 여러 작업이 동시에 실행되는 효과를 준다.
thread는 각각 자신만의 작업 공간을 가진다.
각 thread 사이에서 공유하는 자원이 있을 수 있다.
여러 thread가 자원을 공유하여 작업이 수행되는 경우 서로 자원을 차지하려는 race condition이 발생 할 수 있다. (이렇게 경쟁이 발생하는 부분을 critical section이라 한다.)
critical section에 대한 동기화를 구현해주지 않으면 오류가 발생 할 수 있다.

-상태
              run상태
               | ^
         (반복) ↓ |(cpu 배분)
시작 -->  쓰레드풀(runnable상태) ----------> (Not runnable 상태)
                            sleap(시간)(시간이 지나면 깨어난다.)
                            wait()(notify(), notifyall()로 깨워야한다.)
                            join()(특정 쓰레드가 끝나야 깨어난다.)
                            <----------

-우선순위
Thread.MIN_PRIORITY(=1) ~ Thread.MAX_PRIORITY(=10)
디폴트 우선순위 : Thread.NORMAL_PRIORITY(=5)
우선 순위가 높은 Thread가 CPU의 배분을 받을 확률이 높다.(우선 순위를 제일 높게 설정한다고 항상 먼저 실행됨을 보장 할 수는 없다.)
setPriority()/getPriority()


-critical section 과 semaphore
critical section은 두 개 이상의 thread가 동시에 접근 하는 경우 문제가 생길 수 있기 때문에 동시에 접근할 수 없는 영역
semaphore는 특별한 형태의 시스템 객체이며 get/release 두 개의 기능이 있다.
한 순간 오직 하나의 thread 만이 semaphore를 얻을 수 있고, 나머지 thread들은 대기(blocking) 상태가 된다.
semaphore를 얻은 thread 만이 critical section에 들어갈 수 있다.

-synchronized 메서드
객체의 메소드에 synchronized 키워드 사용해서 현재 이 메서드가 속해있는 객체에 lock을 건다.
자바에서는 deadlock을 방지하는 기술이 제공되지 않으므로 되도록이면 synchronized 메서드에서 다른 synchronized 메서드는 호출하지 않도록 한다.
deadlock: 두 스레드가 다른 스레드의 잠금 해제를 기다리기 때문에 서로를 영원히 차단할 때 데드락이 발생한다.
