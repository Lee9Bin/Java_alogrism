*객체
정의: 의사나 행위가 미치는 대상(사전적 의미)
     구체적, 추상적 데이터의 단위(학생, 회원, 생산, 주문)

-객체 지향 프로그램 구현
1. 객체를 정의
2. 제공하는 기능들을 구현
3. 객체들의 기능들 간의 소통을 통하여 객체간 협력 구현

ex) class 학생{
    속성이 멤버변수로 선언된다.
    int studentId;
    String studentName;

    기능은 함수로 구현
    접근제어자 반환타입 함수이름(매개변수){
    지역변수(함수내에서만 사용하는 변수, 함수가 종료되면 자동으로 반환되는 변수)
    }
}


*생성자
-일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new와 함께 호출
 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출
    클래스 참조변수 = new 클래스
new키워드에 의해 객체(클래스 인스턴스가 힙메모리에 생성이 되고)가 생성 참조변수에는 인스턴스 값을 가르키는 메모리 주소값이 담김
즉 참조변수는 인스턴스를 가르키는 리모컨이고 인스턴스는 실제 값이라 생각해보자

-기본생성자
클래스 내부에 생성자가 하나도!!! 없다면 컴파일러가 생성자 코드를 넣어줌
그래서 이때는 구현하지 않아도 생성자 호출 가능

-생성자 오버로딩
생성자를 두개 이상 구현하는 경우
따라서
클래스(매개변수){
} ---->구현을 하면 컴파일러는 기본 생성자를 넣어주지 않기 때문에
클래스(){} 기본생성자를 사용할거면 선언해야해


*접근제어자
클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드

-private : 같은 클래스 내부에서만 접근 가능 ( 외부 클래스, 상속 관계의 클래스에서도 접근 불가)
           멤버 변수에 대해 접근 수정할 수 있게 get(), set()메서드를 사용
           그렇다면 get()만 쓰면 읽기만 가능하게 하지
           이를통해 정보 은닉을 하고 최소한의 정보를 오픈함으로써 객체의 오류를 방지
-아무것도 없음 (default) : 같은 패키지 내부에서만 접근 가능 ( 상속 관계라도 패키지가 다르면 접근 불가)
-protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
-public : 클래스의 외부 어디서나 접근 할 수 있음


*this
-인스턴스 자신의 메모리를 가르킨다.
-생성자에서 또 다른 생성자를 호출 할때 사용
ex)public Person() {
   		this("이름없음", 1);
   	}

   	public Person(String name, int age) {
   		this.name = name;
   		this.age = age;
   	}
-자신의 주소값을 반환


*static 변수
데이터 영역 메모리
인스턴스가 생성될 때 만들어지는 변수가 아닌, 처음 프로그램이 메모리에 로딩될 때 메모리를 할당
(따라서 클래스 이름으로 호출 가능)
여러 인스턴스가 공유하는 기준 값이 필요한 경우
ex)학생마다 새로운 학번을 만들어야 하는 경우


*클래스 상속
새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능을 확장해서 구현
이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 상속

-상속의 문법
    하위        상위
class B extends A{
}

-하위 클래스가 생성 되는 과정
하위 클래스를 생성하면 상위 클래스가 먼저 생성 됨
클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출 한다.
어떻게?? super 키워드를 통해

-super
하위 클래스에서 가지는 상위 클래스에 대한 참조 값
super()는 상위 클래스의 기본 생성자를 호출 함
하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출 된다. ( 이때 반드시 상위 클래스의 기본 생성자가 존재 해야 함)
상위 클래스의 기본 생성자가 없는 경우 ( 다른 생성자가 있는 경우 ) 하위 클래스에서는 생성자에서는 super를 이용하여 명시적으로 상위 클래스의 생성자를 호출 함
super는 생성된 상위 클래스 인스턴스의 참조 값을 가지므로 super를 이용하여 상위 클래스의 메서드나 멤버 변수에 접근할 수 있음

-상속에서 인스턴스 메모리의 상태
항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.

-형변환(업캐스팅)
상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성 가능
Customer customerLee = new VIPCustomer();
상위 클래스 타입의 변수에 하위 클래스 변수가 대입 가능
VIPCustomer vCustomer = new VIPCustomer();
addCustomer(vCustomer);
int addCustomer(Customer customer){
}
why? 항상 상위 클래스의 인스턴스가 먼저 생성되고, 하위 클래스의 인스턴스가 생성된다.
하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환이 가능하다.
상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅)이 된다.
(그 역은 성립하지 않음)

주의!!
VIPCustomer() 생성자에 의해 VIPCustomer 클래스의 모든 멤버 변수에 대한 메모리는 생성되었지만,
변수의 타입이 Customer 이므로 실제 접근 가능한 변수나 메서드는 Customer의 변수와 메서드임

-하위 클래스에서 메서드 재정의하기(오버라이딩)
상위클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우
하위 클래스에서 동일한 이름!!!의 메서드를 재정의 할 수 있다.


* @overriding 애노테이션
애노테이션은 원래 주석이라는 의미
컴파일러에게 특별한 정보를 제공해주는 역할
@Overrid : 재정의된 메서드라는 정보 제공
@FunctionalInterface: 함수형 인터페이스라는 정보 제공
@Deprecated: 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용된다.
@SupperssWarnings: 특정 경고가 나타나지 않도록한다.

*메서드의 호출과 실행
자바는 모든 메서드가 가상 메서드.
메서드(함수)의 이름은 주소값을 나타낸다.
메서드는 명령어의 set이고(Instruction Set), 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치함
해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 명령어가 실행된다.
이때 메서드에서 사용하는 변수들은 스택 메모리에 위치하게 된다.
따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
인스턴스가 생성되면 변수는 힙 메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드된다.

*가상 메서드
메서드가 호출되면 메서드 이름으로 바로 호출되는게 아니라 메소드 이름이 가리키는 가상 테이블을 보고
각 클래스가 가지고 있는 메서드 주소를 참조해서 호출한다.
가상 메서드 테이블에서 해당 메서드에 대한 주소를 가지고 있다.
재정의 된 경우에는 재정의된 메서드의 주소를 가르킨다.
ex)                          메서드      주소               영역
-포유류클래스 가상 메서드 테이블   a(재정의됨)   0xfwefw --->  [포유류클래스 a()]
                      b(재정의 되지 않음) 0xf1234 --->  [포유류클래스 b()]<-
-사람클래스 가상메서드 테이블     a(재정의됨)   0xfwefw --->  [사람클래스 a()]   |
                      b(재정의 되지 않음) 0xf1234 ----------------------|

*다형성
하나의 코드가 여러 자료형으로 구현되어 실행된다.
같은 코드에서 여러 다른 실행 결과가 나온다.
정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
잘 활용하면 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있다.
상속과 오버라이딩을 통해 구현한다.

*다운캐스팅
업캐스팅된 클래스를 다시 원래의 타입으로 형변환 하는거
instanceof로 원래 누구의 인스턴스인지 체크 가능 이를 활용하여 조건절에 맞으면 다운캐스팅을 실행
하위클래스 변수 = (하위클래스) 변수

*추상 클래스
구현 코드 없이 메서드의 선언만 있는 추상 메서드(abstract method)를 포함한 클래스
메서드 선언(declaration) : 반환타입, 메서드 이름, 매개변수로 구성
메서드 정의(definition) : 메서드 구현(implementation)과 동일한 의미 구현부(body) 를 가짐 ({ })
예) int add(int x, int y); // 선언
int add(int x, int y){ } // 구현부가 있음, 추상 메서드 아님
abstract 예약어를 사용
추상 클래스는 new 할 수 없음 ( 인스턴스화 할 수 없음 )

*템플릿 메서드
추상 메서드나 구현 된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
final로 선언하여 하위 클래스에서 재정의 할 수 없게 한다.
프레임워크에서 많이 사용되는 설계 패턴
추상 클래스로 선언된 상위 클래스에서 템플릿 메서드를 활용하여 전체적인 흐름을 정의 하고 하위 클래스에서
다르게 구현되어야 하는 부분은 추상 메서드로 선언하여 하위 클래스에서 구현 하도록 한다.

-final
final 변수 : 값이 변경될 수 없는 상수
public static final double PI = 3.14;

final 메서드 : 하위 클래스에서 재정의 할 수 없는 메서드
final 클래스 : 상속할 수 없는 클래스

*인터페이스
모든 메서드가 추상 메서드로 선언이 된다.(자바 8 부터 디폴트 메서드(default method)와 정적 메서드(static method) 기능의 제공으로 일부 구현 코드가 있다.)
모든 변수는 상수로 선언이 된다(public static final).
클래스에서 특정한 기능을 구현하도록 강제하는 역할을 한다.
따라서 추상클래스에서 상속을 통해 구현하는 느낌과 비슷하다고 생각이된다.

인터페이스 사이에서도 상속이 가능

*Object 클래스
모든클래스의 최상위 클래스
모든 클래스는 Object에서 상속받고, Object 클래스의 메서드 중 일부는 재정의해서 사용할 수 있음
컴파일러가 extends Object를 추가함 ex) class Student => class Student extends Object

-equals(), hashCode()메서드
equals메서드는 두 인스턴스의 주소값을 비교하여 같으면 true 다르면 false를 반환한다.
따라서 인스턴스가 다르더라도 논리적으로 동일하면 true를 반환하도록 재정의 가능하다
hashCode메서드는 (힙메모리에 인스턴스가 저장되는 방식이 hash방식)인스턴스의 주소를 반환한다.
----> 인스턴스가 같다: 두 인스턴스에 대한 equals()의 반환 값이 true 동일한 hashCode() 값을 반환 해야한다.
논리적으로 동일함을 위해 equals() 메서드를 재정의 하였다면 hashCode()메서드도 재정의 하여 동일한 hashCode 값이 반환되도록 한다.

*자료구조
프로그램에서 사용할 많은 데이터를 메모리 상에서 관리하는 여러 구현방법들
효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다.
자료의 효율적인 관리는 프로그램의 수행속도와 밀접한 관련이 있다.
따라서, 여러 자료 구조 중에서 구현하려는 프로그램에 맞는 최적의 자료 구조를 활용해야 하므로 자료구조에 대한 이해를 해야한다.

--선형자료구조 = 한줄로 자료를 관리한다. 앞뒤 요소가 1대1 관계
-배열(Array): 선형으로 자료를 관리하고 정해진 크기의 메모리를 먼저 할당받아 사용하고, 자료의 물리적 위치와 논리적위치가 같다(어느 위치에 있는 요소를 꺼내오는 연산이 빨라,추가 삭제가 연산이 느려).

-연결리스트(LinkedList) = 선형으로 자료를 관리하고 자료가 추가될 때마다 메모리를 할당받고, 자료는 링크로 연결된다. 따라서 자료의 물리적 위치와 논리적 위치가 다를 수 있다.(삽입 삭제의 연산이 빨라, 위치를 찾는 연산이 느려)

-스택(Stack) = 가장 나중에 입력된 데이터가 가장 먼저 출려되는 구조(프링글스과자 생각)

-큐(Queue) = 가장 먼저 입력된 자료가 가장 먼저 출력 되는 구조(줄서기 생각)

--비선형자료구조
트리(Tree) = 부모 노드와 자식 노드간의 연결로 이루어진 자료구조
-이진 트리(binary tree): 부모노드에 자식 노드가 두개 이하인 트리
 대표적으로 힙(heap)과 이진 검색 트리(binary search tree)를 주로 사용
 힙 = 우선순위 큐를 구현할 때 사용된다.
     Max heap구조 - 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우
     Min heap구조 - 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는 경우

 이진 검색 트리 = 검색을 위한 자료구조 자료(key)의 중복을 허용하지 않는다.
              왼쪽 자식 노드는 부모보다 작은 값, 오른쪽 자식은 큰 값을 가진다.
              검색에 걸리는 시간이 부모를 기준으로 반반씩 쪼개 지기 때문에 log(n)의 시간복잡도를 가진다.

그래프 = 정점과 간선들의 유한 집합
-인접행렬과 인접 리스트로 구현 할 수 있다. 이때 그래프를 탐색하는 대표적인 방법 DFS, BFS
1: 1, 2, 3     0 1 0 1
2: 1, 4        1 0 1 0
3: 1           0 1 0 0
4: 2           1 0 0 0

해싱 = 자료 검색을 하기 위한 자료구조
      키에 대한 자료를 검색하기 위한 사전 개념의 자료구조 --- 파이썬의 딕셔너리와 같은..
      23: 23,123,224 24: 24,124,224 ...


*재너릭 자료형
클래스에서 사용하는 변수의 자료형이 여려개 일 수 있는데, 그 기능은 동일한 경우 클래스의 자료형을 특정하지 않고 추후 해당 클래스를 사용할 때 지정할 수 있도록 선언
실제 사용되는 자료형의 변환은 컴파일러에 의해 검증되므로 안정적이다.
컬렉션 프레임워크에서 많이 사용되고 있다.

-자료형 매개변수라는 의미의 T: 이 클래스를 사용하는 시점에 실제 사용한 자료형을 지정, static 변수는 사용할 수 없다.
(E: element, K: key 등 여러 알파벳을 의미에 따라 사용가능)

-<> 다이아몬드 연산자
<>를 다이아몬드 연산자라 한다.
ArrayList list = new ArrayList<>();  //다이아몬든 연산자 내부에서 자료형은 생략가능 함

-<T extends 클래스>
T라는 위치에 어떤 자료형이 들어갈 수 있게돼 근데 만약 예제에서 프린터에 물이 들어간다? 그럼 안되잖아.
그래서 상속을 사용해 T자료형의 범위를 제한 할 수 있다.

-제너릭 메서드
자료형 매개변수를 메서드의 매개변수나 반환 값으로 가지는 메서드는 자료형 매개 변수가 하나 이상인 경우도 있다.
제네릭 클래스가 아니어도 내부에 제네릭 메서드는 구혀현하요 사용할 수 있다.
ex) public <자료형 매개변수 > 반환형 메서드 이름(자료형 매개변수..){}

*컬렉션 프레임워크
프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK라이브러리, 개발에 소요되는 시간을 절약하면서 최적화 된 알고리즘을 사용할 수 있다.
여러 구현 클래스와 인터페이스의 활용에 대한 이해가 필요하다.
java.util 패키지에 구현되어 있다.
자료구조에 따라 우리가 만든 클래스에 대해서는 equals,hashcode   comparable,Comparator을 재정의 해야해 !!!!

*Iterator
컬렉션 프레임워크에 저장된 요소들을 하나씩 차례로 참조한다.
순서가 있는 List인터페이스의 경우는 사용하지 않고 get메서드를 활용 할 수 있지만
set 인터페이스의 경우 get메서드가 제공되지 않으므로 iterator을 활용하여 객체를 순회한다.
hasNext(): 이후에 요소가 더 있는지 체크하는 메서드, 요소가 있다면 true를 반환
next(): 다음에 있는 요소를 반환
